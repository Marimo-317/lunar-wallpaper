#!/usr/bin/env node
/**
 * Claude Flow v3.0 - Memory Manager
 * Lightweight, SQLite-independent memory and state management
 * Provides persistent storage for AI learning and system state
 */

const fs = require('fs-extra');
const path = require('path');
const crypto = require('crypto');
const winston = require('winston');

class MemoryManager {
    constructor(options = {}) {
        this.options = {
            memoryPath: options.memoryPath || path.join(process.cwd(), 'hive-mind-memory'),
            maxMemorySize: options.maxMemorySize || 100 * 1024 * 1024, // 100MB
            compressionEnabled: options.compressionEnabled !== false,
            backupEnabled: options.backupEnabled !== false,
            maxBackups: options.maxBackups || 5,
            ...options
        };
        
        // In-memory caches for performance
        this.cache = {
            patterns: new Map(),
            knowledge: new Map(),
            sessions: new Map(),
            agents: new Map(),
            solutions: new Map()
        };
        
        // Setup logger
        this.logger = this.setupLogger();
        
        // Initialize memory system
        this.initializeMemorySystem();
        
        this.logger.info('üíæ Memory Manager v3.0 initialized');
        this.logger.info(`üìÅ Memory path: ${this.options.memoryPath}`);
    }
    
    setupLogger() {
        return winston.createLogger({
            level: 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.colorize(),
                winston.format.printf(({ timestamp, level, message, ...meta }) => {
                    return `${timestamp} [MEMORY] ${level}: ${message} ${Object.keys(meta).length ? JSON.stringify(meta) : ''}`;
                })
            ),
            transports: [
                new winston.transports.Console(),
                new winston.transports.File({ 
                    filename: path.join(this.options.memoryPath, 'memory-manager.log'),
                    maxsize: 10485760,
                    maxFiles: 3
                })
            ]
        });
    }
    
    initializeMemorySystem() {
        // Ensure memory directory exists
        fs.ensureDirSync(this.options.memoryPath);
        
        // Initialize memory stores
        this.stores = {
            patterns: new MemoryStore('patterns', this.options.memoryPath, this.logger),
            knowledge: new MemoryStore('knowledge', this.options.memoryPath, this.logger),
            sessions: new MemoryStore('sessions', this.options.memoryPath, this.logger),
            agents: new MemoryStore('agents', this.options.memoryPath, this.logger),
            solutions: new MemoryStore('solutions', this.options.memoryPath, this.logger),
            metrics: new MemoryStore('metrics', this.options.memoryPath, this.logger)
        };
        
        // Load existing data into cache
        this.loadCacheFromStores();
        
        // Setup periodic cleanup
        this.setupPeriodicMaintenance();
    }
    
    async loadCacheFromStores() {
        this.logger.info('üîÑ Loading memory cache from persistent stores...');
        
        try {
            for (const [storeName, store] of Object.entries(this.stores)) {
                const data = await store.loadAll();
                
                if (this.cache[storeName]) {
                    for (const [key, value] of Object.entries(data)) {
                        this.cache[storeName].set(key, value);
                    }\n                }\n            }\n            \n            this.logger.info('‚úÖ Memory cache loaded successfully');\n            this.logMemoryStats();\n            \n        } catch (error) {\n            this.logger.error('Failed to load memory cache:', error.message);\n        }\n    }\n    \n    setupPeriodicMaintenance() {\n        // Run maintenance every 30 minutes\n        setInterval(() => {\n            this.performMaintenance();\n        }, 30 * 60 * 1000);\n    }\n    \n    // =================================================================\n    // PATTERN MANAGEMENT\n    // =================================================================\n    \n    async storePattern(pattern) {\n        const patternId = pattern.id || crypto.randomUUID();\n        const enhancedPattern = {\n            ...pattern,\n            id: patternId,\n            storedAt: Date.now(),\n            accessCount: pattern.accessCount || 0,\n            lastAccessed: Date.now()\n        };\n        \n        // Store in cache\n        this.cache.patterns.set(patternId, enhancedPattern);\n        \n        // Persist to disk\n        await this.stores.patterns.save(patternId, enhancedPattern);\n        \n        this.logger.info(`üìä Pattern stored: ${patternId}`);\n        return patternId;\n    }\n    \n    async getPattern(patternId) {\n        // Try cache first\n        if (this.cache.patterns.has(patternId)) {\n            const pattern = this.cache.patterns.get(patternId);\n            pattern.accessCount = (pattern.accessCount || 0) + 1;\n            pattern.lastAccessed = Date.now();\n            return pattern;\n        }\n        \n        // Load from disk\n        const pattern = await this.stores.patterns.load(patternId);\n        if (pattern) {\n            pattern.accessCount = (pattern.accessCount || 0) + 1;\n            pattern.lastAccessed = Date.now();\n            this.cache.patterns.set(patternId, pattern);\n        }\n        \n        return pattern;\n    }\n    \n    async findPatterns(criteria) {\n        const patterns = [];\n        \n        for (const [patternId, pattern] of this.cache.patterns) {\n            let matches = true;\n            \n            if (criteria.domain && pattern.signature?.domain !== criteria.domain) {\n                matches = false;\n            }\n            \n            if (criteria.complexity && pattern.signature?.complexity !== criteria.complexity) {\n                matches = false;\n            }\n            \n            if (criteria.category && pattern.signature?.category !== criteria.category) {\n                matches = false;\n            }\n            \n            if (criteria.minConfidence && pattern.confidence < criteria.minConfidence) {\n                matches = false;\n            }\n            \n            if (matches) {\n                patterns.push(pattern);\n            }\n        }\n        \n        return patterns.sort((a, b) => b.confidence - a.confidence);\n    }\n    \n    // =================================================================\n    // KNOWLEDGE MANAGEMENT\n    // =================================================================\n    \n    async storeKnowledge(knowledge) {\n        const knowledgeId = knowledge.id || crypto.randomUUID();\n        const enhancedKnowledge = {\n            ...knowledge,\n            id: knowledgeId,\n            storedAt: Date.now(),\n            relevanceScore: knowledge.relevanceScore || 0.5,\n            category: knowledge.category || 'general'\n        };\n        \n        this.cache.knowledge.set(knowledgeId, enhancedKnowledge);\n        await this.stores.knowledge.save(knowledgeId, enhancedKnowledge);\n        \n        this.logger.info(`üß† Knowledge stored: ${knowledgeId}`);\n        return knowledgeId;\n    }\n    \n    async getKnowledge(knowledgeId) {\n        if (this.cache.knowledge.has(knowledgeId)) {\n            return this.cache.knowledge.get(knowledgeId);\n        }\n        \n        const knowledge = await this.stores.knowledge.load(knowledgeId);\n        if (knowledge) {\n            this.cache.knowledge.set(knowledgeId, knowledge);\n        }\n        \n        return knowledge;\n    }\n    \n    async findKnowledge(criteria) {\n        const knowledge = [];\n        \n        for (const [knowledgeId, item] of this.cache.knowledge) {\n            let matches = true;\n            \n            if (criteria.domain && item.domain !== criteria.domain) {\n                matches = false;\n            }\n            \n            if (criteria.category && item.category !== criteria.category) {\n                matches = false;\n            }\n            \n            if (criteria.tags && criteria.tags.length > 0) {\n                const hasMatchingTag = criteria.tags.some(tag => \n                    item.tags?.includes(tag)\n                );\n                if (!hasMatchingTag) {\n                    matches = false;\n                }\n            }\n            \n            if (matches) {\n                knowledge.push(item);\n            }\n        }\n        \n        return knowledge.sort((a, b) => b.relevanceScore - a.relevanceScore);\n    }\n    \n    // =================================================================\n    // SESSION MANAGEMENT\n    // =================================================================\n    \n    async storeSession(session) {\n        const sessionId = session.id;\n        \n        // Serialize complex objects\n        const serializedSession = this.serializeSession(session);\n        \n        this.cache.sessions.set(sessionId, serializedSession);\n        await this.stores.sessions.save(sessionId, serializedSession);\n        \n        this.logger.info(`üìù Session stored: ${sessionId}`);\n        return sessionId;\n    }\n    \n    async getSession(sessionId) {\n        if (this.cache.sessions.has(sessionId)) {\n            return this.deserializeSession(this.cache.sessions.get(sessionId));\n        }\n        \n        const session = await this.stores.sessions.load(sessionId);\n        if (session) {\n            const deserialized = this.deserializeSession(session);\n            this.cache.sessions.set(sessionId, session);\n            return deserialized;\n        }\n        \n        return null;\n    }\n    \n    serializeSession(session) {\n        return {\n            ...session,\n            agents: session.agents ? Object.fromEntries(session.agents) : {},\n            patterns: session.patterns || [],\n            solutions: session.solutions || [],\n            serializedAt: Date.now()\n        };\n    }\n    \n    deserializeSession(serializedSession) {\n        return {\n            ...serializedSession,\n            agents: new Map(Object.entries(serializedSession.agents || {})),\n            patterns: serializedSession.patterns || [],\n            solutions: serializedSession.solutions || []\n        };\n    }\n    \n    // =================================================================\n    // SOLUTION MANAGEMENT\n    // =================================================================\n    \n    async storeSolution(solution) {\n        const solutionId = solution.id || crypto.randomUUID();\n        const enhancedSolution = {\n            ...solution,\n            id: solutionId,\n            storedAt: Date.now(),\n            effectiveness: solution.effectiveness || 0.5,\n            usageCount: solution.usageCount || 0\n        };\n        \n        this.cache.solutions.set(solutionId, enhancedSolution);\n        await this.stores.solutions.save(solutionId, enhancedSolution);\n        \n        this.logger.info(`üí° Solution stored: ${solutionId}`);\n        return solutionId;\n    }\n    \n    async getSolution(solutionId) {\n        if (this.cache.solutions.has(solutionId)) {\n            const solution = this.cache.solutions.get(solutionId);\n            solution.usageCount = (solution.usageCount || 0) + 1;\n            solution.lastUsed = Date.now();\n            return solution;\n        }\n        \n        const solution = await this.stores.solutions.load(solutionId);\n        if (solution) {\n            solution.usageCount = (solution.usageCount || 0) + 1;\n            solution.lastUsed = Date.now();\n            this.cache.solutions.set(solutionId, solution);\n        }\n        \n        return solution;\n    }\n    \n    // =================================================================\n    // METRICS AND ANALYTICS\n    // =================================================================\n    \n    async updateMetrics(metrics) {\n        const currentMetrics = await this.stores.metrics.load('system') || {\n            totalSessions: 0,\n            successfulResolutions: 0,\n            averageResolutionTime: 0,\n            patternsLearned: 0,\n            knowledgeItems: 0,\n            lastUpdated: Date.now()\n        };\n        \n        const updatedMetrics = {\n            ...currentMetrics,\n            ...metrics,\n            lastUpdated: Date.now()\n        };\n        \n        await this.stores.metrics.save('system', updatedMetrics);\n        this.logger.info('üìä System metrics updated');\n        \n        return updatedMetrics;\n    }\n    \n    async getMetrics() {\n        return await this.stores.metrics.load('system') || {\n            totalSessions: 0,\n            successfulResolutions: 0,\n            averageResolutionTime: 0,\n            patternsLearned: 0,\n            knowledgeItems: 0,\n            lastUpdated: Date.now()\n        };\n    }\n    \n    // =================================================================\n    // MAINTENANCE AND OPTIMIZATION\n    // =================================================================\n    \n    async performMaintenance() {\n        this.logger.info('üßπ Starting memory maintenance...');\n        \n        try {\n            // Clean up old patterns\n            await this.cleanupOldPatterns();\n            \n            // Optimize knowledge base\n            await this.optimizeKnowledgeBase();\n            \n            // Compress old sessions\n            await this.compressOldSessions();\n            \n            // Update cache statistics\n            await this.updateCacheStatistics();\n            \n            // Create backup if enabled\n            if (this.options.backupEnabled) {\n                await this.createBackup();\n            }\n            \n            this.logger.info('‚úÖ Memory maintenance completed');\n            \n        } catch (error) {\n            this.logger.error('Memory maintenance failed:', error.message);\n        }\n    }\n    \n    async cleanupOldPatterns() {\n        const cutoffTime = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30 days\n        let cleanedCount = 0;\n        \n        for (const [patternId, pattern] of this.cache.patterns) {\n            if (pattern.lastAccessed < cutoffTime && pattern.accessCount < 5) {\n                this.cache.patterns.delete(patternId);\n                await this.stores.patterns.delete(patternId);\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            this.logger.info(`üóëÔ∏è Cleaned up ${cleanedCount} old patterns`);\n        }\n    }\n    \n    async optimizeKnowledgeBase() {\n        // Remove duplicate knowledge items\n        const knowledgeByHash = new Map();\n        let duplicatesRemoved = 0;\n        \n        for (const [knowledgeId, knowledge] of this.cache.knowledge) {\n            const hash = this.hashKnowledge(knowledge);\n            \n            if (knowledgeByHash.has(hash)) {\n                // Keep the one with higher relevance score\n                const existing = knowledgeByHash.get(hash);\n                if (knowledge.relevanceScore > existing.relevanceScore) {\n                    // Remove existing, keep current\n                    this.cache.knowledge.delete(existing.id);\n                    await this.stores.knowledge.delete(existing.id);\n                    knowledgeByHash.set(hash, knowledge);\n                } else {\n                    // Remove current, keep existing\n                    this.cache.knowledge.delete(knowledgeId);\n                    await this.stores.knowledge.delete(knowledgeId);\n                }\n                duplicatesRemoved++;\n            } else {\n                knowledgeByHash.set(hash, knowledge);\n            }\n        }\n        \n        if (duplicatesRemoved > 0) {\n            this.logger.info(`üîÑ Removed ${duplicatesRemoved} duplicate knowledge items`);\n        }\n    }\n    \n    hashKnowledge(knowledge) {\n        // Create hash from key knowledge properties\n        const hashData = `${knowledge.domain}:${knowledge.category}:${knowledge.pattern}:${JSON.stringify(knowledge.tags || [])}`;\n        return crypto.createHash('sha256').update(hashData).digest('hex');\n    }\n    \n    async compressOldSessions() {\n        const cutoffTime = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days\n        let compressedCount = 0;\n        \n        for (const [sessionId, session] of this.cache.sessions) {\n            if (session.startTime < cutoffTime && session.status === 'completed') {\n                // Create compressed version\n                const compressed = {\n                    id: session.id,\n                    issueNumber: session.issueNumber,\n                    status: session.status,\n                    startTime: session.startTime,\n                    duration: session.duration,\n                    metrics: session.metrics,\n                    compressed: true,\n                    compressedAt: Date.now()\n                };\n                \n                this.cache.sessions.set(sessionId, compressed);\n                await this.stores.sessions.save(sessionId, compressed);\n                compressedCount++;\n            }\n        }\n        \n        if (compressedCount > 0) {\n            this.logger.info(`üóúÔ∏è Compressed ${compressedCount} old sessions`);\n        }\n    }\n    \n    async updateCacheStatistics() {\n        const stats = {\n            patterns: this.cache.patterns.size,\n            knowledge: this.cache.knowledge.size,\n            sessions: this.cache.sessions.size,\n            agents: this.cache.agents.size,\n            solutions: this.cache.solutions.size,\n            lastUpdated: Date.now()\n        };\n        \n        await this.stores.metrics.save('cache_stats', stats);\n    }\n    \n    async createBackup() {\n        const backupDir = path.join(this.options.memoryPath, 'backups');\n        fs.ensureDirSync(backupDir);\n        \n        const backupName = `memory-backup-${new Date().toISOString().split('T')[0]}.json`;\n        const backupPath = path.join(backupDir, backupName);\n        \n        const backupData = {\n            timestamp: Date.now(),\n            version: '3.0',\n            patterns: Object.fromEntries(this.cache.patterns),\n            knowledge: Object.fromEntries(this.cache.knowledge),\n            solutions: Object.fromEntries(this.cache.solutions),\n            metrics: await this.getMetrics()\n        };\n        \n        fs.writeJsonSync(backupPath, backupData, { spaces: 2 });\n        \n        // Clean up old backups\n        await this.cleanupOldBackups(backupDir);\n        \n        this.logger.info(`üíæ Backup created: ${backupName}`);\n    }\n    \n    async cleanupOldBackups(backupDir) {\n        const backupFiles = fs.readdirSync(backupDir)\n            .filter(file => file.startsWith('memory-backup-'))\n            .map(file => ({\n                name: file,\n                path: path.join(backupDir, file),\n                stat: fs.statSync(path.join(backupDir, file))\n            }))\n            .sort((a, b) => b.stat.mtime - a.stat.mtime);\n        \n        // Keep only the most recent backups\n        if (backupFiles.length > this.options.maxBackups) {\n            const filesToDelete = backupFiles.slice(this.options.maxBackups);\n            \n            for (const fileInfo of filesToDelete) {\n                fs.unlinkSync(fileInfo.path);\n            }\n            \n            this.logger.info(`üóëÔ∏è Cleaned up ${filesToDelete.length} old backups`);\n        }\n    }\n    \n    // =================================================================\n    // UTILITY METHODS\n    // =================================================================\n    \n    logMemoryStats() {\n        const stats = {\n            patterns: this.cache.patterns.size,\n            knowledge: this.cache.knowledge.size,\n            sessions: this.cache.sessions.size,\n            agents: this.cache.agents.size,\n            solutions: this.cache.solutions.size\n        };\n        \n        this.logger.info('üìä Memory statistics:', stats);\n    }\n    \n    async getMemoryUsage() {\n        const memoryUsage = process.memoryUsage();\n        const diskUsage = await this.calculateDiskUsage();\n        \n        return {\n            process: {\n                rss: Math.round(memoryUsage.rss / 1024 / 1024) + ' MB',\n                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + ' MB',\n                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + ' MB',\n                external: Math.round(memoryUsage.external / 1024 / 1024) + ' MB'\n            },\n            cache: {\n                patterns: this.cache.patterns.size,\n                knowledge: this.cache.knowledge.size,\n                sessions: this.cache.sessions.size,\n                agents: this.cache.agents.size,\n                solutions: this.cache.solutions.size\n            },\n            disk: diskUsage\n        };\n    }\n    \n    async calculateDiskUsage() {\n        try {\n            const stats = fs.statSync(this.options.memoryPath);\n            const size = await this.getDirSize(this.options.memoryPath);\n            \n            return {\n                path: this.options.memoryPath,\n                size: Math.round(size / 1024 / 1024) + ' MB',\n                maxSize: Math.round(this.options.maxMemorySize / 1024 / 1024) + ' MB',\n                usage: Math.round((size / this.options.maxMemorySize) * 100) + '%'\n            };\n        } catch (error) {\n            return { error: error.message };\n        }\n    }\n    \n    async getDirSize(dirPath) {\n        let totalSize = 0;\n        \n        const files = fs.readdirSync(dirPath);\n        \n        for (const file of files) {\n            const filePath = path.join(dirPath, file);\n            const stats = fs.statSync(filePath);\n            \n            if (stats.isDirectory()) {\n                totalSize += await this.getDirSize(filePath);\n            } else {\n                totalSize += stats.size;\n            }\n        }\n        \n        return totalSize;\n    }\n    \n    // Clear all memory (useful for testing)\n    async clearAllMemory() {\n        this.logger.warn('üö® Clearing all memory data!');\n        \n        // Clear caches\n        this.cache.patterns.clear();\n        this.cache.knowledge.clear();\n        this.cache.sessions.clear();\n        this.cache.agents.clear();\n        this.cache.solutions.clear();\n        \n        // Clear persistent stores\n        for (const store of Object.values(this.stores)) {\n            await store.clear();\n        }\n        \n        this.logger.info('‚úÖ All memory data cleared');\n    }\n    \n    // Get system status\n    getStatus() {\n        return {\n            system: 'memory-manager-v3',\n            status: 'operational',\n            memoryPath: this.options.memoryPath,\n            cacheSize: {\n                patterns: this.cache.patterns.size,\n                knowledge: this.cache.knowledge.size,\n                sessions: this.cache.sessions.size,\n                agents: this.cache.agents.size,\n                solutions: this.cache.solutions.size\n            },\n            options: {\n                maxMemorySize: this.options.maxMemorySize,\n                compressionEnabled: this.options.compressionEnabled,\n                backupEnabled: this.options.backupEnabled,\n                maxBackups: this.options.maxBackups\n            }\n        };\n    }\n}\n\n// =================================================================\n// MEMORY STORE CLASS\n// =================================================================\n\nclass MemoryStore {\n    constructor(name, basePath, logger) {\n        this.name = name;\n        this.basePath = basePath;\n        this.logger = logger;\n        this.filePath = path.join(basePath, `${name}.json`);\n        \n        // Ensure file exists\n        this.ensureFile();\n    }\n    \n    ensureFile() {\n        if (!fs.existsSync(this.filePath)) {\n            fs.writeJsonSync(this.filePath, {}, { spaces: 2 });\n        }\n    }\n    \n    async save(key, data) {\n        try {\n            const store = this.loadFile();\n            store[key] = {\n                ...data,\n                _metadata: {\n                    savedAt: Date.now(),\n                    version: '3.0'\n                }\n            };\n            this.saveFile(store);\n        } catch (error) {\n            this.logger.error(`Failed to save ${this.name}[${key}]:`, error.message);\n            throw error;\n        }\n    }\n    \n    async load(key) {\n        try {\n            const store = this.loadFile();\n            const data = store[key];\n            \n            if (data && data._metadata) {\n                // Remove metadata before returning\n                const { _metadata, ...cleanData } = data;\n                return cleanData;\n            }\n            \n            return data;\n        } catch (error) {\n            this.logger.error(`Failed to load ${this.name}[${key}]:`, error.message);\n            return null;\n        }\n    }\n    \n    async loadAll() {\n        try {\n            const store = this.loadFile();\n            const cleanStore = {};\n            \n            for (const [key, data] of Object.entries(store)) {\n                if (data && data._metadata) {\n                    const { _metadata, ...cleanData } = data;\n                    cleanStore[key] = cleanData;\n                } else {\n                    cleanStore[key] = data;\n                }\n            }\n            \n            return cleanStore;\n        } catch (error) {\n            this.logger.error(`Failed to load all from ${this.name}:`, error.message);\n            return {};\n        }\n    }\n    \n    async delete(key) {\n        try {\n            const store = this.loadFile();\n            delete store[key];\n            this.saveFile(store);\n        } catch (error) {\n            this.logger.error(`Failed to delete ${this.name}[${key}]:`, error.message);\n            throw error;\n        }\n    }\n    \n    async clear() {\n        try {\n            this.saveFile({});\n        } catch (error) {\n            this.logger.error(`Failed to clear ${this.name}:`, error.message);\n            throw error;\n        }\n    }\n    \n    loadFile() {\n        try {\n            return fs.readJsonSync(this.filePath);\n        } catch (error) {\n            this.logger.warn(`Failed to read ${this.filePath}, creating new:`, error.message);\n            return {};\n        }\n    }\n    \n    saveFile(data) {\n        try {\n            fs.writeJsonSync(this.filePath, data, { spaces: 2 });\n        } catch (error) {\n            this.logger.error(`Failed to write ${this.filePath}:`, error.message);\n            throw error;\n        }\n    }\n}\n\nmodule.exports = MemoryManager;